}
return(sapply(z,oo))
}
#########################################################################
### Simulate latent variables Z1 aqnd Z2
### The ordinal outcome W is obtained by discretizing Z
########################################################################
n<-2000
alpha<-0;beta_1<--1
thrd1<-c(-1.5,0)
X<-runif(n,-3,3)
Z1<-alpha+beta_1*X+rnorm(n)
plot(Z1~X)
abline(h=thrd1[1],col="red")
abline(h=thrd1[2],col="red")
# abline(h=thrd[3],col="red")
# abline(h=thrd[4],col="red")
W1<-ordinalize(Z1,thrd1)
table(W1)
alpha<-0;beta_2<--1.5
thrd2<-c(1,3)
Z2<-alpha+beta_2*X+rnorm(n)
W2<-ordinalize(Z2,thrd2)
table(W2)
model1<-vglm(formula=(W1-1)~X,family = cumulative(link = probit,parallel = TRUE))
beta1.hat<--coef(model1)[3]
thrd1.hat<-c(coef(model1)[1],coef(model1)[2])
##### surrogate variable
surrogate.bootstrap<-function(w,x,beta.hat,thrd.hat){
cc<-c(-Inf,thrd.hat,Inf)
S<-rtmvnorm(1,mean=(beta.hat*x),sigma=1,lower=cc[w],upper=cc[w+1])
return(S)
}
S1.boot<-rep(NA,n)
for(i in 1:n){S1.boot[i]<-surrogate.bootstrap(W1[i],X[i],beta1.hat,thrd1.hat)}
windows()
plot(S1.boot~X)
model2<-vglm(formula=(W2-1)~X,family = cumulative(link = probit,parallel = TRUE))
beta2.hat<--coef(model2)[3]
thrd2.hat<-c(coef(model2)[1],coef(model2)[2])
S2.boot<-rep(NA,n)
for(i in 1:n){S2.boot[i]<-surrogate.bootstrap(W2[i],X[i],beta2.hat,thrd2.hat)}
windows()
plot(S2.boot~X)
windows()
D<-S2.boot-S1.boot
plot(D~X)
scatter.smooth(X,D, span = 0.5,degree=2,lpars = list(col = "red", lwd = 3),ylab="D")
abline(h=0,lty=2)
source('C:/Users/greenweb/Downloads/Proportionality.r', echo=TRUE)
table(W1)
table(W2)
library(VGAM)
fit1 <- vglm(y ~ x, data = df4[1:2000, ],
cumulative(link = probit, parallel = TRUE)
fit2 <- update(fit1, data = df4[2001:4000, ])
fit2 <- update(fit1, data = df4[2001:4000, ])
library(VGAM)
fit1 <- vglm(y ~ x, data = df4[1:2000, ],
cumulative(link = probit, parallel = TRUE)
)
fit1 <- vglm(y ~ x, data = df4[1:2000, ],
cumulative(link = probit, parallel = TRUE))
fit2 <- update(fit1, data = df4[2001:4000, ])
library(ggplot2)
library(VGAM)
fit1 <- vglm(y ~ x, data = df4[1:2000, ],
cumulative(link = probit, parallel = TRUE))
fit2 <- update(fit1, data = df4[2001:4000, ])
s1 <- surrogate(fit1)
s2 <- surrogate(fit2)
d <- data.frame(D = s1 - s2, X = df4[1:2000, ]$x)
ggplot(d, aes(x = X, y = D)) +
geom_point() +
geom_smooth()
d <- data.frame(D = s1 - s2, X = df4[2001:4000, ]$x)
ggplot(d, aes(x = X, y = D)) +
geom_point() +
geom_smooth(se = FALSE)
# Fit separate models to the df4 data set and genrate the difference in
# surrogate values
library(VGAM)
fit1 <- vglm(y ~ x, data = df4[1:2000, ],
cumulative(link = probit, parallel = TRUE))
fit2 <- update(fit1, data = df4[2001:4000, ])
s1 <- surrogate(fit1)
s2 <- surrogate(fit2)
d <- data.frame(D = s1 - s2, X = df4[1:2000, ]$x)
# Scatterplot of D vs. X
p <- ggplot(d, aes(x = X, y = D)) +
geom_point() +
geom_smooth(col = "red", se = FALSE)
# Figure ?
pdf(file = "proportionality.pdf", width = 7, height = 5)
print(p)
dev.off()
table(W1)
table(W2)
fit1
fit2
?df3
exp(2) - exp(1 / 2)
plnorm(2)
dlnorm(2)
# Fit models with various link functions to the simulated data
fit.probit <- polr(y ~ x + I(x ^ 2), data = df3, method = "probit")
fit.logistic <- polr(y ~ x + I(x ^ 2), data = df3, method = "logistic")
fit.loglog <- polr(y ~ x + I(x ^ 2), data = df3, method = "loglog")  # correct link
fit.cloglog <- polr(y ~ x + I(x ^ 2), data = df3, method = "cloglog")
# Construc Q-Q plots of the surrogate residuals for each model
p1 <- autoplot(fit.probit, nsim = 100, what = "qq")
p2 <- autoplot(fit.logistic, nsim = 100, what = "qq")
p3 <- autoplot(fit.loglog, nsim = 100, what = "qq")
p4 <-  autoplot(fit.cloglog, nsim = 100, what = "qq")
library(MASS)
# Fit models with various link functions to the simulated data
fit.probit <- polr(y ~ x + I(x ^ 2), data = df3, method = "probit")
fit.logistic <- polr(y ~ x + I(x ^ 2), data = df3, method = "logistic")
fit.loglog <- polr(y ~ x + I(x ^ 2), data = df3, method = "loglog")  # correct link
fit.cloglog <- polr(y ~ x + I(x ^ 2), data = df3, method = "cloglog")
# Construc Q-Q plots of the surrogate residuals for each model
p1 <- autoplot(fit.probit, nsim = 100, what = "qq")
p2 <- autoplot(fit.logistic, nsim = 100, what = "qq")
p3 <- autoplot(fit.loglog, nsim = 100, what = "qq")
p4 <-  autoplot(fit.cloglog, nsim = 100, what = "qq")
grid.arrange(p1, p2, p3, p4, ncol = 2)  # bottom left plot is correct model
pdf(file = "link.pdf", width = 7, height = 5)
grid.arrange(p1, p2, p3, p4, ncol = 2)  # bottom left plot is correct model
dev.off()
pdf(file = "link.pdf", width = 7, height = 7)
grid.arrange(p1, p2, p3, p4, ncol = 2)  # bottom left plot is correct model
dev.off()
plot(gof(fit.cloglog))
plot(gof(fit.loglog))
plot(gof(fit.loglog, nsim = 50))
plot(gof(fit.cloglog, nsim = 50))
plot(gof(fit.probit, nsim = 50))
plot(gof(fit.logistic, nsim = 50))
plot(gof(fit.loglog, nsim = 50))
plot(gof(fit.loglog, nsim = 500))
plot(gof(fit.logistic, nsim = 500))
?gof
?ks.test
?wine
?ordinal::wine
x <- c("Abc", "DEFF", "AJKJdjdksKDJ")
tolower(x)
library(xlsx)
library(readxl)
?read_xlsx
onelines <- read_excel(file.choose(), sheet = 1, skip = 2, col_names = TRUE)
head(onelines)
library(tm)
library(tidytext)
vs <- VectorSource(onelines$One.liner)
names(onelines)
names(onelines) <- "One.liner"
vs <- VectorSource(onelines$One.liner)
vs
dt <- DocumentTermMatrix(vs)
inspect(vs)
?VCorpus
vc <- VCorpus(vs)
inspect(vc)
inspect(vc[[1]])
citation(package = "sure")
citation(package = "anomalyDetection")
?alpha.f
?adjustcolor
library(ggplot2)
library(MASS)
library(ordinal)
library(PResiduals)
library(rms)
library(VGAM)
library(sure)
data(wine, package = "ordinal")
wine.clm <- clm(rating ~ temp * contact, data = wine)  # default logit link
grid.arrange(
autoplot(wine.clm, nsim = 10, what = "qq"),
autoplot(wine.clm, nsim = 10, what = "fitted"),
autoplot(wine.clm, nsim = 10, what = "cov", x = wine$temp),
autoplot(wine.clm, nsim = 10, what = "cov", x = wine$contact),
ncol = 2
)
?VGAM::wine
table(df4)
library(sure)
table(df4)
table(df4$y)
library(rms)
fit.orm <- orm(y ~ x, data = df2, family = "probit", x = TRUE)
library(ggplot2)
autoplot(fit.orm)
autoplot(fit.orm, what = "covariate", x = df2$x)
autoplot(fit.orm, what = "covariate", x = df2$x, method = "jitter")
autoplot(fit.orm, what = "covariate", x = df2$x, method = "jitter", jitter.scale = "response")
library(mgcv)
?mgcv::ocat
fit <- gam(y ~ s(x), data = df2, family = ocat(R = length(unique(df2$y))))
fit <- gam(as.integer(y) ~ s(x), data = df2, family = ocat(R = length(unique(df2$y))))
fit
table(df2$y)
fit <- gam(as.integer(y) ~ s(x), data = df2, family = ocat(R = 5)
)
library(mgcv)
data(df2, package = "sure")
fit <- gam(as.integer(y) ~ s(x), data = df2, family = ocat(R = 5))
head(fit$fitted.values)
names(fit)
head(predict(fit))
?predict.gam
head(predict(fit, type = "response"))
rowSums(predict(fit, type = "response"))
y <- as.integer(df2$y)  # response values
s <- runif(length(y), min = y, max = y + 1)  # surogate response values
prob <- predict(fit, type = "response")  # fitted probabilities
j <- seq_len(ncol(prob))  # j = 1, 2, ..., J
jmat <- matrix(rep(j, times = nrow(prob)), ncol = ncol(prob),
byrow = TRUE)  # 1, 2, ..., J; 1, 2, ..., J; ...
r <- s - rowSums((jmat + 0.5) * prob1)   # residuals
r <- s - rowSums((jmat + 0.5) * prob)   # residuals
scatter.smooth(df1$x, r, lpars = list(lwd = 2, col = "red"))
r <- residuals(fit)
scatter.smooth(df1$x, r, lpars = list(lwd = 2, col = "red"))
?resid.gam
?residuals.gam
r <- residuals(fit, type = "pearson")
r <- residuals(fit, type = "working")
scatter.smooth(df1$x, r, lpars = list(lwd = 2, col = "red"))
r <- residuals(fit, type = "response")
scatter.smooth(df1$x, r, lpars = list(lwd = 2, col = "red"))
?ocat
?VGAM::vgam
fit <- vgam(y ~ s(x), data = df2, cumulative(link = probit, parallel = TRUE))
library(VGAM)
fit <- vgam(y ~ s(x), data = df2, cumulative(link = probit, parallel = TRUE))
fit
# Generate residuals by jittering on the response scale
y <- as.integer(df2$y)  # response values
s <- runif(length(y), min = y, max = y + 1)  # surogate response values
prob <- predict(fit, type = "response")  # fitted probabilities
j <- seq_len(ncol(prob))  # j = 1, 2, ..., J
jmat <- matrix(rep(j, times = nrow(prob)), ncol = ncol(prob),
byrow = TRUE)  # 1, 2, ..., J; 1, 2, ..., J; ...
r <- s - rowSums((jmat + 0.5) * prob)   # residuals
scatter.smooth(df1$x, r, lpars = list(lwd = 2, col = "red"))
head(predict(fit, type = "response"))
head(jmat)
sure:::getFittedProbs.vglm
head(prob)
head(fit@fitted.values)
class(fit)
fit
fit <- vgam(y ~ s(x), data = df2,
family = cumulative(link = probit, parallel = TRUE))
y <- as.integer(df2$y)  # response values
s <- runif(length(y), min = y, max = y + 1)  # surogate response values
prob <- predict(fit, type = "response")  # fitted probabilities
j <- seq_len(ncol(prob))  # j = 1, 2, ..., J
jmat <- matrix(rep(j, times = nrow(prob)), ncol = ncol(prob),
byrow = TRUE)  # 1, 2, ..., J; 1, 2, ..., J; ...
r <- s - rowSums((jmat + 0.5) * prob)   # residuals
# Residual-by-covariate plot
scatter.smooth(df1$x, r, lpars = list(lwd = 2, col = "red"))
# Fit multinomial models (w/wo quadratic trend)
fit <- vgam(y ~ x, data = df2,
family = cumulative(link = probit, parallel = TRUE))
# Generate residuals by jittering on the response scale
y <- as.integer(df2$y)  # response values
s <- runif(length(y), min = y, max = y + 1)  # surogate response values
prob <- predict(fit, type = "response")  # fitted probabilities
j <- seq_len(ncol(prob))  # j = 1, 2, ..., J
jmat <- matrix(rep(j, times = nrow(prob)), ncol = ncol(prob),
byrow = TRUE)  # 1, 2, ..., J; 1, 2, ..., J; ...
r <- s - rowSums((jmat + 0.5) * prob)   # residuals
# Residual-by-covariate plot
scatter.smooth(df1$x, r, lpars = list(lwd = 2, col = "red"))
fit <- vglm(y ~ x, data = df2,
family = cumulative(link = probit, parallel = TRUE))
# Generate residuals by jittering on the response scale
y <- as.integer(df2$y)  # response values
s <- runif(length(y), min = y, max = y + 1)  # surogate response values
prob <- predict(fit, type = "response")  # fitted probabilities
j <- seq_len(ncol(prob))  # j = 1, 2, ..., J
jmat <- matrix(rep(j, times = nrow(prob)), ncol = ncol(prob),
byrow = TRUE)  # 1, 2, ..., J; 1, 2, ..., J; ...
r <- s - rowSums((jmat + 0.5) * prob)   # residuals
# Residual-by-covariate plot
scatter.smooth(df1$x, r, lpars = list(lwd = 2, col = "red"))
scatter.smooth(df2$x, r, lpars = list(lwd = 2, col = "red"))
# Fit multinomial models (w/wo quadratic trend)
fit <- vgam(y ~ s(x), data = df2,
family = cumulative(link = probit, parallel = TRUE))
# fit <- vglm(y ~ x, data = df2,
# family = cumulative(link = probit, parallel = TRUE))
# Generate residuals by jittering on the response scale
y <- as.integer(df2$y)  # response values
s <- runif(length(y), min = y, max = y + 1)  # surogate response values
prob <- predict(fit, type = "response")  # fitted probabilities
j <- seq_len(ncol(prob))  # j = 1, 2, ..., J
jmat <- matrix(rep(j, times = nrow(prob)), ncol = ncol(prob),
byrow = TRUE)  # 1, 2, ..., J; 1, 2, ..., J; ...
r <- s - rowSums((jmat + 0.5) * prob)   # residuals
# Residual-by-covariate plot
scatter.smooth(df2$x, r, lpars = list(lwd = 2, col = "red"))
?vgam
fit.vgam <- vgam(y ~ s(x), family = cumulative(link = probit, parallel = TRUE),
data = df2)
library(sure)
library(VGAM)
library(ggplot2)
fit.vgam <- vgam(y ~ s(x), family = cumulative(link = probit, parallel = TRUE),
data = df2)
# Residual vs. covariate plots: jittering
set.seed(103)
p1 <- autoplot(fit.vgam, what = "covariate", x = df2$x, method = "jitter")
p2 <- autoplot(fit.vgam, what = "covariate", x = df2$x, method = "jitter",
jitter.scale = "response")
# Figure?
pdf(file = "heteroscedasticity2.pdf", width = 8, height = 4)
grid.arrange(p1, p2, ncol = 2)
dev.off()
set.seed(103)
p1 <- autoplot(fit.vgam, what = "covariate", x = df2$x, method = "jitter", nsim = 10)
p2 <- autoplot(fit.vgam, what = "covariate", x = df2$x, method = "jitter", nsim = 10,
jitter.scale = "response")
grid.arrange(p1, p2, ncol = 2)
set.seed(103)
p1 <- autoplot(fit.vgam, what = "covariate", x = df2$x, method = "jitter", nsim = 10, alpha = 0.5)
p2 <- autoplot(fit.vgam, what = "covariate", x = df2$x, method = "jitter", nsim = 10, alpha = 0.5,
jitter.scale = "response")
grid.arrange(p1, p2, ncol = 2)
grid.arrange(p1, p2, ncol = 1)
library(readr)
ff <- read_csv("C:/Users/greenweb/Desktop/Data sets/forestfires.csv")
View(forestfires)
hist(ff$area)
hist(log(ff$area))
library(randomForest)
fit <- randomForest(log(area) ~ ., data = ff, importance = TRUE)
fit <- randomForest(log(area + 0.01) ~ ., data = ff, importance = TRUE)
anyNA(ff)
log(ff$area)
log(ff$area + 0.01)
fit <- randomForest(log(area + 0.01) ~ ., data = ff, importance = TRUE)
hist(log(ff$area + 0.01))
hist(log(ff$area + 0.1))
log(0.01)
fit <- lm(log(area + 0.01) ~ ., data = ff)
summary(fit)
fit <- lm(log(area + 0.1) ~ ., data = ff)
summary(fit)
fit <- lm(log(area + 0.1) ~ .^2, data = ff)
summary(fit)
set.seed(103)
p1 <- autoplot(fit.vgam, what = "covariate", x = df2$x, method = "jitter",
xlab = "x")
p2 <- autoplot(fit.vgam, what = "covariate", x = df2$x, method = "jitter",
jitter.scale = "response", xlab = "x")
pdf(file = "heteroscedasticity2.pdf", width = 8, height = 4)
grid.arrange(p1, p2, ncol = 1)
dev.off()
pdf(file = "heteroscedasticity2.pdf", width = 8, height = 4)
grid.arrange(p1, p2, ncol = 2)
dev.off()
fit.probit <- polr(y ~ x + I(x ^ 2), data = df3, method = "probit")
library(MASS)
library(sure)
fit.probit <- polr(y ~ x + I(x ^ 2), data = df3, method = "probit")
fit.logistic <- polr(y ~ x + I(x ^ 2), data = df3, method = "logistic")
fit.loglog <- polr(y ~ x + I(x ^ 2), data = df3, method = "loglog")  # correct link
fit.cloglog <- polr(y ~ x + I(x ^ 2), data = df3, method = "cloglog")
par(mfrow = c(2, 2))
plot(gof(fit.probit, nsim = 10))
plot(gof(fit.logistic, nsim = 10))
plot(gof(fit.loglog, nsim = 10))
plot(gof(fit.cloglog, nsim = 10))
par(mfrow = c(2, 2))
plot(gof(fit.probit, nsim = 50))
plot(gof(fit.logistic, nsim = 50))
plot(gof(fit.loglog, nsim = 50))
plot(gof(fit.cloglog, nsim = 50))
par(mfrow = c(2, 2))
plot(gof(fit.probit, nsim = 100))
plot(gof(fit.logistic, nsim = 100))
plot(gof(fit.loglog, nsim = 100))
plot(gof(fit.cloglog, nsim = 100))
warnings()
?gof
par(mfrow = c(2, 2))
plot(gof(fit.probit, nsim = 100, test = "ad"))
plot(gof(fit.logistic, nsim = 100, test = "ad"))
plot(gof(fit.loglog, nsim = 100, test = "ad"))
plot(gof(fit.cloglog, nsim = 100, test = "ad"))
plot(gof(fit.probit, nsim = 100, test = "ad"), main = "")
# Figure ?
pdf(file = "gof.pdf", width = 7, height = 7)
par(mfrow = c(2, 2))
plot(gof(fit.probit, nsim = 100, test = "ad"), main = "")
plot(gof(fit.logistic, nsim = 100, test = "ad"), main = "")
plot(gof(fit.loglog, nsim = 100, test = "ad"), main = "")
plot(gof(fit.cloglog, nsim = 100, test = "ad"), main = "")
dev.off()
plot(gof(fit.probit, nsim = 100, test = "ad"), main = "", type = "l")
z <- gof(fit.probit)
class(z)
pdf(file = "gof.pdf", width = 7, height = 7)
par(mfrow = c(2, 2))
plot(gof(fit.probit, nsim = 100, test = "ad"), main = "")
plot(gof(fit.logistic, nsim = 100, test = "ad"), main = "")
plot(gof(fit.loglog, nsim = 100, test = "ad"), main = "")
plot(gof(fit.cloglog, nsim = 100, test = "ad"), main = "")
dev.off()
gof
?gof
pdf(file = "gof.pdf", width = 7, height = 7)
par(mfrow = c(2, 2))
set.seed(8491)  # for reproducibility
plot(gof(fit.probit, nsim = 100, test = "ad"), main = "")
plot(gof(fit.logistic, nsim = 100, test = "ad"), main = "")
plot(gof(fit.loglog, nsim = 100, test = "ad"), main = "")
plot(gof(fit.cloglog, nsim = 100, test = "ad"), main = "")
dev.off()
?par
par(mfrow = c(2, 2), mar = c(2, 4, 2, 2) + 0.1)
set.seed(8491)  # for reproducibility
plot(gof(fit.probit, nsim = 100, test = "ad"), main = "")
plot(gof(fit.logistic, nsim = 100, test = "ad"), main = "")
plot(gof(fit.loglog, nsim = 100, test = "ad"), main = "")
plot(gof(fit.cloglog, nsim = 100, test = "ad"), main = "")
par(mfrow = c(2, 2), mar = c(3, 4, 2, 2) + 0.1)
set.seed(8491)  # for reproducibility
plot(gof(fit.probit, nsim = 100, test = "ad"), main = "")
plot(gof(fit.logistic, nsim = 100, test = "ad"), main = "")
plot(gof(fit.loglog, nsim = 100, test = "ad"), main = "")
plot(gof(fit.cloglog, nsim = 100, test = "ad"), main = "")
par(mfrow = c(2, 2), mar = c(4, 4, 2, 2) + 0.1)
set.seed(8491)  # for reproducibility
plot(gof(fit.probit, nsim = 100, test = "ad"), main = "")
plot(gof(fit.logistic, nsim = 100, test = "ad"), main = "")
plot(gof(fit.loglog, nsim = 100, test = "ad"), main = "")
plot(gof(fit.cloglog, nsim = 100, test = "ad"), main = "")
# Figure ?
pdf(file = "gof.pdf", width = 7, height = 7)
par(mfrow = c(2, 2), mar = c(4, 4, 2, 2) + 0.1)
set.seed(8491)  # for reproducibility
plot(gof(fit.probit, nsim = 100, test = "ad"), main = "")
plot(gof(fit.logistic, nsim = 100, test = "ad"), main = "")
plot(gof(fit.loglog, nsim = 100, test = "ad"), main = "")
plot(gof(fit.cloglog, nsim = 100, test = "ad"), main = "")
dev.off()
?gof
?ks.test
(5/6)^(10) + 10*(1/6)*(5/6)^9 + 45*(1/6)^2*(5/6)^8
?pbinom
pbinom(2, size = 10, prob = 1/6)
dbinom(0, size = 10, prob = 1/6)
plot(dbinom(x, size = 10, prob = 1/6))
curve(dbinom(x, size = 10, prob = 1/6))
plot(dbinom(size = 10, prob = 1/6))
plot(dbinom(x, size = 10, prob = 1/6))
x <- 0:10
y <- sapply(x, function(.) dbinom(., size = 10, prob = 1?6))
y <- sapply(x, function(.) dbinom(., size = 10, prob = 1/6))
sum(y)
plot(x, y, type = "h")
plot(x, y, type = "h")
points(x, y, pch = 19)
y
library(readr)
LasVegasTripAdvisorReviews_Dataset <- read_delim("C:/Users/greenweb/Desktop/Data sets/LasVegasTripAdvisorReviews-Dataset.csv",
";", escape_double = FALSE, trim_ws = TRUE)
View(LasVegasTripAdvisorReviews_Dataset)
d <- LasVegasTripAdvisorReviews_Dataset
d$Score <- as.ordered(d$Score)
library(MASS)
head(d)
fit <- polr(Score ~ Pool + Gym, data = d)
summary(fit)
library(sure)
fit <- polr(Score ~ `Nr. reviews` + Pool + Gym, data = d)
summary(fit)
res <- resids(fit)
plot(d$`Nr. reviews`, res)
autoplot(fit, what = "qq")
library(ggplot2)
autoplot(fit, what = "qq")
autoplot(fit, what = "qq". nsim = 20)
autoplot(fit, what = "qq", nsim = 20)
fit <- polr(Score ~ `Nr. reviews` + Pool + Gym, data = d, method = "cloglog")
autoplot(fit, what = "qq", nsim = 20)
table(d$Score)
autoplot(fit, what = "covariate", x = d$Pool)
autoplot(fit, what = "covariate", x = d$Gym)
autoplot(fit, what = "fitted")
?VGAM::vgam
?ordinal::wine
?data
d <- data()
head(d)
names(d)
head(d$title)
head(d$item)
head(d$results)
head(d$results[2L])
class(d$results)
head(d$results[, 2L])
head(d$results[, 3L])
d <- d$results[, 3L]
d
for (i in d) {data(i)}
